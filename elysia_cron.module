<?
/**
 * ELYSIA_CRON
 * 
 * Features:
 * - cron-like configuration of each single task (each task has is own rules 
 *   about when to execute).
 * - grouping of tasks in channels (parallel lines of execution).
 * - you can disable all tasks, an entire channel or a single task via configuration.
 * - time statistics of each task and of the whole channel.
 * - modules can define extra cron tasks, each with own default cron-rules
 *   (overridable by site administrator).
 * - administrator can define custom tasks (call to functions with parameters)
 * - protection from external cron calling by cron_key or allowed hosts list.
 * - ensure all shutdown hook functions launched by cron jobs are launched inside
 *   cron protection (ex: search_update_totals()).
 * 
 * Channels are groups of tasks. Each channel is a "parallel line" of execution
 * (= multiple channels can be executed simultaneously).
 * Tasks inside a channel will be executed sequentially (if they should).
 * 
 * INSTALL:
 * - You need to modify cron.php. Replace the line "drupal_cron_run()" with:
 *   -----------------------------------------------------------------------
 *   if (function_exists('elysia_cron_run'))
 *     elysia_cron_run();
 *   else
 *     drupal_cron_run();
 *   -----------------------------------------------------------------------
 * - You should also change the system crontab to launch cron process each minute.
 * 
 * TODO Possibilità di forzare il lancio di un singolo processo
 * 
 */

function elysia_cron_menu($maycache) {
  $items[] = array();
  if ($maycache) {
    $items[] = array(
      'path' => 'admin/build/cron',
      'title' => t('Cron Settings'),
      'description' => t('View and manage cron table'),
      'callback' => 'elysia_cron_admin_page',
      'access' => user_access('administer elysia_cron'),
    );
    $items[] = array(
      'path' => 'admin/build/cron/status',
      'type' => MENU_DEFAULT_LOCAL_TASK,
      'title' => t('Status'),
    );
    $items[] = array(
      'path' => 'admin/build/cron/reset',
      'type' => MENU_LOCAL_TASK,
      'title' => t('Reset statistics'),
      'callback' => 'elysia_cron_reset_page',
      'access' => user_access('administer elysia_cron'),
    );
    $items[] = array(
      'path' => 'admin/build/cron/settings',
      'type' => MENU_LOCAL_TASK,
      'title' => t('Settings'),
      'callback' => 'drupal_get_form',
      'callback arguments' => 'elysia_cron_settings_form',
      'access' => user_access('administer elysia_cron'),
    );
  }
  return $items;
}

function elysia_cron_perm() {
  return array('administer elysia_cron');
}

function elysia_cron_admin_page() {
  elysia_cron_initialize();

  global $elysia_cron_settings, $elysia_cron_settings_by_context, $elysia_cron_current_context, $cron_completed, $cron_completed_time;
  
  //dprint('Disabled: '.variable_get('elysia_cron_disabled', false));
  $v = variable_get('elysia_cron_disabled', false);
  $output .= '<p>Global disable: <i>'.($v ? '<span class="warn">YES</span>':'no').'</i></p>';
  $output .= '<p>Last context executed: <i>'.variable_get('elysia_cron_last_context', '').'</i></p>';
  
  if (variable_get('elysia_cron_semaphore', 0))
    $output .= '<p><span class="warn">Semaforo globale attivo: '.elysia_cron_date(variable_get('elysia_cron_semaphore', 0)).'</span></p>';
  
  $running = '';
  foreach ($elysia_cron_settings_by_context as $context => $data) 
    if (variable_get('elysia_cron_ctx_'.$context.'_running', false))
      $running .= $context.' ';
  if ($running)
    $output .= '<p>Running: <span class="warn">'.$running.'</span></p>';
    
  $output .= '<p>Last run: '.elysia_cron_date(variable_get('elysia_cron_last_run', 0)).'</p>';
  
  foreach ($elysia_cron_settings_by_context as $context => $data) {
    $running = variable_get('elysia_cron_ctx_'.$context.'_running', false);
    $output .= '<h3>'.$context.($running ? ' (Running since '.elysia_cron_date($running).')' : '').($data['#data']['disabled'] ? ' <span class="warn">(DISABLED)</span>' : '').'</h3>';
    $output .= '<p>Last run: '.elysia_cron_date($data['#data']['last_run']).'</p>';
    $output .= '<p>Last execution time: '.$data['#data']['last_execution_time'].'s (Shutdown: '.$data['#data']['last_shutdown_time'].'s) (Avg total: '.$data['#data']['avg_execution_time'].'s, Max total: '.$data['#data']['max_execution_time'].'s)</p>';
    $output .= '<p>Execution count: '.$data['#data']['execution_count'].'</p>';
    if ($data['#data']['last_aborted']) {
      $output .= '<p>Last aborted: <span class="warn">On function '.$data['#data']['last_abort_function'].'</span></p>';
    }
    if ($data['#data']['abort_count']) {
      $output .= '<p>Abort count: <span class="warn">'.$data['#data']['abort_count'].'</span></p>';
    }
    
    $rows = array();
    foreach ($data as $function => $conf) if ($function != '#data') {
      $rows[] = array(
        ($conf['running'] ? '*' : '').($conf['disabled'] ? 'D' : ''), 
        ($conf['disabled'] ? '<strike>'.$function.'</strike>' : (!$conf['running'] ? '<b>'.$function.'</b>' : '<b><u>'.$function.'</u></b>')).(elysia_cron_should_run($conf) ? ' <small title="'.t('Waiting for execution').'">(w)</small>' : ''), 
        array('data' => '<i>'.elysia_cron_description($function).'</i>','colspan' => 4)
      );
      $rows[] = array(
        '', $conf['rule'], elysia_cron_date($conf['last_run']), $conf['last_execution_time'].'s',
        $conf['execution_count'], $conf['avg_execution_time'].'s / '.$conf['max_execution_time'].'s'
       
      );
    }
    $output .= theme('table', array('Run', 'Func / Rule', 'Last run', 'Last exec time', 'Exec count', 'Avg/Max Exec time'), $rows);
  }
  
  //dprint($elysia_cron_settings);
  
  $output .= '<p>Note: i tempi dei singoli processi non tengono conto degli shutdown time (che vengono conteggiati globalmente a livello di contesto).</p>';
  $output .= '<p>In caso di abort in genere il processo non viene chiuso correttamente, e cosi\' anche le sue statistiche.</p>';
  
  return $output;
}

function elysia_cron_reset_page() {
  global $elysia_cron_settings, $elysia_cron_settings_by_context;
  elysia_cron_initialize();
  
  foreach ($elysia_cron_settings as $function => $conf) {
    variable_set('elysia_cron_'.$function.'_last_execution_time', 0);
    variable_set('elysia_cron_'.$function.'_execution_count', 0);
    variable_set('elysia_cron_'.$function.'_avg_execution_time', 0);
    variable_set('elysia_cron_'.$function.'_max_execution_time', 0);
  }
  
  foreach ($elysia_cron_settings_by_context as $context => $conf) { 
    variable_set('elysia_cron_ctx_'.$context.'_last_execution_time', 0);
    variable_set('elysia_cron_ctx_'.$context.'_execution_count', 0);
    variable_set('elysia_cron_ctx_'.$context.'_avg_execution_time', 0);
    variable_set('elysia_cron_ctx_'.$context.'_max_execution_time', 0);
    variable_set('elysia_cron_ctx_'.$context.'_last_shutdown_time', 0);
    variable_set('elysia_cron_ctx_'.$context.'_abort_count', 0);
  }
  
  drupal_set_message(t('Reset done.'));
  drupal_goto('admin/build/cron');
}

function elysia_cron_settings_form() {
  global $elysia_cron_settings, $elysia_cron_settings_by_context;
  elysia_cron_initialize();

  $form = array();
  
  $form['prefix'] = array(
    '#value' => '<p>All cron rules are in format:<br><code>minutes[space]hours[space]day_of_the_week</code><br>'.
      'Each token can be "*" (execute at each interval) or a comma separated list of values (for day_of_the_week 0 is sunday and 6 is saturday)</p>'
  );
  
  $form['elysia_cron_disabled'] = array(
    '#title' => 'Global disable',
    '#type' => 'checkbox',
    '#default_value' => variable_get('elysia_cron_disabled', false),
  );
  $form['elysia_cron_key'] = array(
    '#title' => 'Cron key',
    '#type' => 'textfield',
    '#default_value' => variable_get('elysia_cron_key', ''),
    '#description' => 'This is used to avoid external cron calling. If you set this cron will by accessible only by calling http://site/cron.php?cron_key=XXX, so you\'ll need to modify system crontab to support this (Logged user with [administer elysia_cron] permission avoid this check).',
  );
  $form['elysia_cron_key'] = array(
    '#title' => 'Allowed hosts',
    '#type' => 'textfield',
    '#default_value' => variable_get('elysia_cron_allowed_hosts', ''),
    '#description' => 'Insert a list of ip addresses separated by , that can run cron.php (Logged user with [administer elysia_cron] permission avoid this check).',
  );
  
  $form['elysia_cron_default_rule'] = array(
    '#title' => 'Default rule',
    '#type' => 'textfield',
    '#default_value' => variable_get('elysia_cron_default_rule', false),
    '#description' => 'If you don\'t specify a rule for a process, and if it has not a module specified one, this rule will apply',
  );
  
  $form['elysia_cron_script_fieldset'] = array(
    '#title' => t('Script'),
    '#type' => 'fieldset',
  );
  $form['elysia_cron_script_fieldset']['elysia_cron_script'] = array(
    '#type' => 'textarea',
    '#default_value' => variable_get('elysia_cron_script', ''),
  );
  
  foreach ($elysia_cron_settings as $function => $conf) if (!$conf['expression']) {
    $form['elysia_cron_'.$function] = array(
      '#title' => 'Function '.$function,
      '#description' => elysia_cron_description($function),
      '#type' => 'fieldset',
    );
    
    $form['elysia_cron_'.$function]['elysia_cron_'.$function.'_context'] = array(
      '#title' => 'Context',
      '#type' => 'textfield',
      '#default_value' => variable_get('elysia_cron_'.$function.'_context', ''),
      '#description' => 'Lascia vuoto per mantenere il contesto di default',
    );
    $form['elysia_cron_'.$function]['elysia_cron_'.$function.'_rule'] = array(
      '#title' => 'Rule',
      '#type' => 'textfield',
      '#default_value' => variable_get('elysia_cron_'.$function.'_rule', ''),
    );
    $form['elysia_cron_'.$function]['elysia_cron_'.$function.'_disabled'] = array(
      '#title' => 'Disabled',
      '#type' => 'checkbox',
      '#default_value' => variable_get('elysia_cron_'.$function.'_disabled', ''),
    );
  }
  
  foreach ($elysia_cron_settings_by_context as $context => $conf) {
    $form['elysia_cron_ctx_'.$context] = array(
      '#title' => 'Context '.$context,
      '#type' => 'fieldset',
    );
    $form['elysia_cron_ctx_'.$context]['elysia_cron_ctx_'.$context.'_disabled'] = array(
      '#title' => 'Disabled',
      '#type' => 'checkbox',
      '#default_value' => variable_get('elysia_cron_ctx_'.$context.'_disabled', ''),
    );
  }
  
  $form['buttons']['submit'] = array('#type' => 'submit', '#value' => t('Save configuration') );
  $form['buttons']['reset'] = array('#type' => 'submit', '#value' => t('Reset to defaults') );

  if (!empty($_POST) && form_get_errors()) {
    drupal_set_message(t('The settings have not been saved because of the errors.'), 'error');
  }

  return $form;
}

function elysia_cron_settings_form_validate($form_id, $form_values) {
  global $elysia_cron_settings;
  
  $script = $form_values['elysia_cron_script'];
  if ($script) {
    $errors = elysia_cron_decode_script($script, false);
    if ($errors) {
      form_set_error('elysia_cron_script', t('Invalid lines:').implode('<br>', $errors));
    }
  }
  
}

function elysia_cron_settings_form_submit($form_id, $form_values) {
  $op = isset($form_values['op']) ? $form_values['op'] : '';

  // Exclude unnecessary elements.
  unset($form_values['submit'], $form_values['reset'], $form_values['form_id'], $form_values['op'], $form_values['form_token']);

  foreach ($form_values as $key => $value) {
    if ($op == t('Reset to defaults')) {
      variable_del($key);
    }
    else {
      if ($value) {
        if (is_array($value) && isset($form_values['array_filter'])) {
          $value = array_keys(array_filter($value));
        }
        variable_set($key, $value);
      } else {
        variable_del($key);
      }
    }
  }
  if ($op == t('Reset to defaults')) {
    drupal_set_message(t('The configuration options have been reset to their default values.'));
  }
  else {
    drupal_set_message(t('The configuration options have been saved.'));
  }
}

function elysia_cron_date($timestamp) {
  // 'd/m/Y H:i'
  return date(variable_get('date_format_short', 'm/d/Y - H:i'), $timestamp); 
}


function elysia_cron_decode_script($text, $apply = true) {
  global $elysia_cron_settings;
  
  $lines = explode("\n", $text);
  $lastcomment = '';
  $errors = array();
  $conf = array();
  foreach ($lines as $line) {
    $line = trim($line);
    if (!empty($line)) {
      if ($line{0} == '#') {
        $lastcomment = trim(substr($line, 1));
        
      } else if (preg_match('/^(-[ ]*|)([0-9*,]+[ ]+[0-9*,]+[ ]+[0-9*,]+)[ ]+(ctx:([a-zA-Z0-9_-]+)[ ]+|)([^(:]+)(\(.*\);|)$/', $line, $r)) {
        $c = array(
          'disabled' => !empty($r[1]),
          'rule' => $r[2],
          'description' => $lastcomment,
          'context' => $r[4] ? $r[4] : 'default',
        );
        $lastcomment = '';
        if (empty($r[6])) {
          if (!isset($elysia_cron_settings[$r[5]])) {
            // Referring a module function that not exists
            $errors[] = $line;
            continue;
          }
          $name = $r[5];
        } else {
          // custom expression, generate a unique name
          $r[5];
          $postfix = '';
          while (isset($elysia_cron_settings[$r[5].$postfix]))
            $postfix = ($postfix?$postfix:0) + 1;
          $name = $r[5].$postfix;
          $c['expression'] = $r[5].$r[6]; 
        }
        if ($apply)
          $elysia_cron_settings[$name] = isset($elysia_cron_settings[$name]) ? array_merge($elysia_cron_settings[$name], $c) : $c;

      } else {
        $errors[] = $line;
      }
    } else {
      $lastcomment = '';
    }
  }
  
  return count($errors) ? $errors : false;
}

function elysia_cron_module_functions() {
  $functions = array();
  foreach (module_implements('cron') as $module)
    $functions[] = array($module, $module .'_cron');
  
  foreach (module_implements('cronapi') as $module) {
    $fn = $module.'_cronapi';
    $l = $fn('list');
    if (is_array($l)) foreach ($l as $function => $desc)
      if (!in_array($function, $functions))
        $functions[] = array($module, $function);
  }

  return $functions;
}

function elysia_cron_initialize($skipscript = false) {
  global $elysia_cron_settings, $elysia_cron_settings_by_context;
  $elysia_cron_settings = array();
  $elysia_cron_settings_by_context = array();
  
  foreach (elysia_cron_module_functions() as $function) {
    $context = variable_get('elysia_cron_'.$function[1].'_context', 'default');
    $rule = variable_get('elysia_cron_'.$function[1].'_rule', '');
    if (!$rule) {
      $fn = $function[0].'_cronapi';
      if (function_exists($fn))
        $rule = $fn('rule', $function[1]);
    }
    if (!$rule)
      $rule = variable_get('elysia_cron_default_rule', '0,15,30,45 * *');

    $elysia_cron_settings[$function[1]] = array(
      'context' => $context,
      'module' => $function[0],
      'rule' => $rule,
      'disabled' => variable_get('elysia_cron_'.$function[1].'_disabled', 0),
      'running' => variable_get('elysia_cron_'.$function[1].'_running', false),
    );
  }
  if (!$skipscript) {
    $script = variable_get('elysia_cron_script', false);
    if ($script)
      elysia_cron_decode_script($script);
  }
  
  foreach ($elysia_cron_settings as $function => &$conf) {
    $conf['last_run'] = variable_get('elysia_cron_'.$function.'_last_run', 0);
    $conf['last_execution_time'] = variable_get('elysia_cron_'.$function.'_last_execution_time', 0);
    $conf['execution_count'] = variable_get('elysia_cron_'.$function.'_execution_count', 0);
    $conf['avg_execution_time'] = variable_get('elysia_cron_'.$function.'_avg_execution_time', 0);
    $conf['max_execution_time'] = variable_get('elysia_cron_'.$function.'_max_execution_time', 0);
    $elysia_cron_settings_by_context[$conf['context']][$function] = &$elysia_cron_settings[$function];
  }

  foreach ($elysia_cron_settings_by_context as $context => $data) {
    $elysia_cron_settings_by_context[$context]['#data'] = array(
      'disabled' => variable_get('elysia_cron_ctx_'.$context.'_disabled', false),
      //'running' => variable_get('elysia_cron_ctx_'.$context.'_running', false),

      'last_run' => variable_get('elysia_cron_ctx_'.$context.'_last_run', 0),
      'last_execution_time' => variable_get('elysia_cron_ctx_'.$context.'_last_execution_time', 0),
      'execution_count' => variable_get('elysia_cron_ctx_'.$context.'_execution_count', 0),
      'avg_execution_time' => variable_get('elysia_cron_ctx_'.$context.'_avg_execution_time', 0),
      'max_execution_time' => variable_get('elysia_cron_ctx_'.$context.'_max_execution_time', 0),
      'last_shutdown_time' => variable_get('elysia_cron_ctx_'.$context.'_last_shutdown_time', 0),
      'last_aborted' => variable_get('elysia_cron_ctx_'.$context.'_last_aborted', 0),
      'abort_count' => variable_get('elysia_cron_ctx_'.$context.'_abort_count', 0),
      'last_abort_function' => variable_get('elysia_cron_ctx_'.$context.'_last_abort_function', ''),
    );
  }
}

function elysia_cron_run() {
  $cron_key = variable_get('elysia_cron_key', '');
  if ($cron_key && !user_access('administer elysia_cron') && $_GET['cron_key'] != $cron_key)
    return;
  $allowed_hosts = variable_get('elysia_cron_allowed_hosts', false);
  if ($allowed_hosts && !user_access('administer elysia_cron') && !in_array($_SERVER['REMOTE_ADDR'], explode(",", $allowed_hosts)))
    return;
  
  variable_set('elysia_cron_last_run', time());
  
  if (variable_get('elysia_cron_disabled', false))
    return;

  // Global Semaphore to avoid concurrent execution of code below
  $semglob = variable_get('elysia_cron_semaphore', 0);
  if ($semglob && (time() - $semglob > 120)) {
    watchdog('cron', 'Semaforo globale elysia cron bloccato da piu\' di 2 minuti, reset.', WATCHDOG_ERROR); //TODO LANG
    variable_del('elysia_cron_semaphore');
    unset($semglob);
  }
  if ($semglob)
    return;
  
  variable_set('elysia_cron_semaphore', time());

  if (!ini_get('safe_mode')) {
    set_time_limit(240);
  }
  elysia_cron_initialize();
  global $elysia_cron_settings, $elysia_cron_settings_by_context, $elysia_cron_current_context, $cron_completed, $cron_completed_time;

  $contexts = array_keys($elysia_cron_settings_by_context);
  $context = variable_get('elysia_cron_last_context', '');
  
  $i = array_search($context, $contexts);
  if ($i === FALSE) $i = -1;
  $k = 0;
  for ($j = ($i + 1) % count($contexts); $k < count($contexts); $j = ($j + 1) % count($contexts)) {
    $sem = variable_get('elysia_cron_ctx_'.$contexts[$j].'_running', false);
    if ($sem && (time() - $sem > 3600)) {
      watchdog('cron', t('Cron context (%context) has been running for more than an hour and is most likely stuck.', array('%context' => $contexts[$j])), WATCHDOG_ERROR);
      //$elysia_cron_settings_by_context[$contexts[$j]]['#data']['running'] = false;
      variable_del('elysia_cron_ctx_'.$contexts[$j].'_running');
      unset($sem);
      elysia_cron_execute_aborted($contexts[$j]);
    }
    if (!$sem && !$elysia_cron_settings_by_context[$contexts[$j]]['#data']['disabled'] && time() - $elysia_cron_settings_by_context[$contexts[$j]]['#data']['last_run'] > 60) { 
      $functions = elysia_cron_active_functions($contexts[$j]);
      if (count($functions)) break;
    }
    $k++;
  }
  if (!$functions || !count($functions)) {
    //watchdog('cron', t('All cron contexts are running or not active.'), WATCHDOG_WARNING);
    variable_del('elysia_cron_semaphore');
    return;
  }
  
  $elysia_cron_current_context = $contexts[$j];
  variable_set('elysia_cron_last_context', $elysia_cron_current_context);
  watchdog('cron', t('Cron context %context run started.', array('%context' => $elysia_cron_current_context)), WATCHDOG_NOTICE);
  
  // Register shutdown callback
  register_shutdown_function('elysia_cron_cleanup');

  // Lock cron semaphore
  variable_set('elysia_cron_ctx_'.$elysia_cron_current_context.'_running', time());
  variable_set('elysia_cron_ctx_'.$elysia_cron_current_context.'_last_run', time());

  variable_del('elysia_cron_semaphore');
    
  foreach ($functions as $function)
    elysia_cron_execute($function);
  
  $cron_completed = true;
  $cron_completed_time = time();
  
  // Cron is really completed after shutdown functions
  register_shutdown_function('elysia_cron_completed');

  // Return TRUE so other functions can check if it did run successfully
  return TRUE;
}

function elysia_cron_execute($function) {
  global $elysia_cron_settings;

  $time = time();
  variable_set('elysia_cron_'.$function.'_last_run', $time);
  variable_set('elysia_cron_'.$function.'_running', true);
  
  try {
    if ($elysia_cron_settings[$function]['expression']) {
      eval($elysia_cron_settings[$function]['expression']);
    } if (function_exists($function)) {
      //sleep(5);
      $function();
    } else {
      $fn = $elysia_cron_settings[$function]['module'].'_cronapi';
      if (function_exists($fn)) {
        $fn('execute', $function);
      } else {
        watchdog('cron', 'Execution of '.$function.' failed, can\'t find function!', WATCHDOG_ERROR);
      }
    }
  } catch (Exception $e) {
    watchdog('cron', 'Exception: '.$e, WATCHDOG_ERROR);
    $exception = true;
    //TODO Manage it
  }

  $time = time() - $time;
  variable_set('elysia_cron_'.$function.'_running', false);
  variable_set('elysia_cron_'.$function.'_last_execution_time', $time);
  $c = variable_get('elysia_cron_'.$function.'_execution_count', 0) + 1;
  variable_set('elysia_cron_'.$function.'_execution_count', $c);
  variable_set('elysia_cron_'.$function.'_avg_execution_time', round(((variable_get('elysia_cron_'.$function.'_avg_execution_time', 0) * ($c - 1)) + $time) / $c, 2));
  $m = variable_get('elysia_cron_'.$function.'_max_execution_time', 0);
  if ($time > $m)
    variable_set('elysia_cron_'.$function.'_max_execution_time', $time);
}

function elysia_cron_execute_aborted($context) {
  global $elysia_cron_settings_by_context;

  variable_set('elysia_cron_ctx_'.$context.'_running', false);
  variable_set('elysia_cron_ctx_'.$context.'_last_aborted', true);
  variable_set('elysia_cron_ctx_'.$context.'_abort_count', variable_get('elysia_cron_ctx_'.$context.'_abort_count', 0) + 1);
  
  foreach ($elysia_cron_settings_by_context[$context] as $function => $conf) if ($function != '#data') {
    if (variable_get('elysia_cron_'.$function.'_running', false)) {
      variable_set('elysia_cron_ctx_'.$context.'_last_abort_function', $function);
      variable_set('elysia_cron_'.$function.'_running', false);
    }
  }
}

/**
 * Shutdown function for cron cleanup.
 * 
 * Used for unexpected termination of code.
 */
function elysia_cron_cleanup() {
  global $elysia_cron_settings, $elysia_cron_current_context, $cron_completed, $cron_completed_time;
  
  if ($cron_completed) return;
  
  // See if the semaphore is still locked.
  if (variable_get('elysia_cron_ctx_'.$elysia_cron_current_context.'_running', FALSE)) {
    watchdog('cron', t('Unexpected temination of cron context %context, aborted.', array('%context' => $elysia_cron_current_context)), WATCHDOG_WARNING);
    
    elysia_cron_execute_aborted($elysia_cron_current_context);
  }
}

/**
 * Successful termination (after all shutdown hooks invoked by cron functions).
 */
function elysia_cron_completed() {
  global $elysia_cron_settings, $elysia_cron_current_context, $cron_completed, $cron_completed_time;
  //dprint("completed ".$elysia_cron_current_context);
  
  // Record cron time
  variable_set('cron_last', time());
  watchdog('cron', t('Cron context %context run completed.', array('%context' => $elysia_cron_current_context)), WATCHDOG_NOTICE);
  
  $time = time() - variable_get('elysia_cron_ctx_'.$elysia_cron_current_context.'_last_run', 0); 
  variable_set('elysia_cron_ctx_'.$elysia_cron_current_context.'_running', false);
  variable_set('elysia_cron_ctx_'.$elysia_cron_current_context.'_last_aborted', false);
  variable_set('elysia_cron_ctx_'.$elysia_cron_current_context.'_last_execution_time', $time);
  $c = variable_get('elysia_cron_ctx_'.$elysia_cron_current_context.'_execution_count', 0) + 1;
  variable_set('elysia_cron_ctx_'.$elysia_cron_current_context.'_execution_count', $c);
  variable_set('elysia_cron_ctx_'.$elysia_cron_current_context.'_avg_execution_time', round(((variable_get('elysia_cron_ctx_'.$elysia_cron_current_context.'_avg_execution_time', 0) * ($c - 1)) + $time) / $c, 2));
  $m = variable_get('elysia_cron_ctx_'.$elysia_cron_current_context.'_max_execution_time', 0);
  if ($time > $m)
    variable_set('elysia_cron_ctx_'.$elysia_cron_current_context.'_max_execution_time', $time);
  variable_set('elysia_cron_ctx_'.$elysia_cron_current_context.'_last_shutdown_time', time() - $cron_completed_time);
}

/**
 * Get all functions that needs to be executed in a context
 */
function elysia_cron_active_functions($context) {
  global $elysia_cron_settings_by_context;

  $functions = array();
  foreach ($elysia_cron_settings_by_context[$context] as $function => $conf) if ($function != '#data') {
    if (elysia_cron_should_run($conf))
      $functions[] = $function;
  }
  return $functions;
}

function elysia_cron_should_run($conf) {
  if ($conf['disabled'])
    return false;
    
  if ((!$conf['last_run']) || (time() - $conf['last_run'] > 7 * 86400))
    return true;

  if (!preg_match('/^([0-9*,]+)[ ]+([0-9*,]+)[ ]+([0-9*,]+)$/', $conf['rule'], $rules)) {
    watchdog('cron', 'Invalid rule found: ' . $conf['rule']);
    return false;
  }
  if ($rules[3] == '*') $rules[3] = '0,1,2,3,4,5,6';
  if ($rules[2] == '*') $rules[2] = '0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23';
  if ($rules[1] == '*') $rules[1] = '0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59';
  
  $table = array();
  foreach (explode(',', $rules[3]) as $d)
    foreach (explode(',', $rules[2]) as $h)
      foreach (explode(',', $rules[1]) as $m)
        $table[] = $d . str_pad($h, 2, '0', STR_PAD_LEFT) . str_pad($m, 2, '0', STR_PAD_LEFT);

  $d = $conf['last_run'] ? date('wHi', $conf['last_run'] + 30) : '00000';
  foreach ($table as $i => $v)
    if ($v >= $d) break;
  if ($v > $d) $i--;
  $i = ($i + 1) % count($table);
  // $i è la posizione del cron subito successivo a quello lanciato l'ultima volta
  // (se l'ultima volta non c'e' stata è il primo, se l'ultima volta è stata oltre il max idem)
  // se now() è >= al cron identificato allora va lanciato
  
  return date('wHi') >= $table[$i];
}

function elysia_cron_description($function) {
  global $elysia_cron_settings;
  
  if ($elysia_cron_settings[$function]['description'])
    return $elysia_cron_settings[$function]['description'];
  
  $fn = $elysia_cron_settings[$function]['module'].'_cronapi';
  if (function_exists($fn)) {
    $l = $fn('list');
    if ($l[$function])
      return $l[$function];
  }
  return theme('elysia_cron_description', $function);
}


/**
 * You can theme this function to provide your description for cron functions, if they do not provide one. 
 */
function theme_elysia_cron_description($function) {
  switch($function) {
    case 'search_cron': return 'Indicizzazione motore di ricerca';
    case 'activitystream_cron': return 'Fetch dei feed RSS e chiamate ad api web per l\'activitystream';
    case 'mailhandler_cron': return 'Fetch delle caselle POP3/IMAP gestite da MailHandler';
    case 'watchdog_cron': return 'Remove expired log messages and flood control events';
    case 'filter_cron': return 'Expire outdated filter cache entries';
    case 'node_cron': return 'Elimina dalla tabella history i nodi visti oltra la soglia dei nodi marcati come nuovi';
    case 'system_cron': return 'Expire cache_path';
    case 'aggregation_cron': return 'Fetch dei feed RSS per il modulo aggregation';
    case 'amazon_cron': return 'Refresh di prodotti Amazon';
    case 'image_cron': return 'Deletes old temp images';
    case 'persistent_login_cron': return 'Expire persistent login';
    case 'trackback_cron': return 'Gestisce la coda dei trackback ping da effettuare';
    case 'update_status_cron': return 'Verifica aggiornamento moduli di sistema (ha una sua frequenza di check)';
    case 'user_karma_cron': return 'Expire user karma / Ricalcolo (ha una sua frequenza di check)';
    case 'votingapi_cron': return 'Aggiornamento stato voti (se non e\' stato impostato come immediato)';
    case 'statistics_cron': return 'Reset day counts / Clean expired access logs';
    case 'googleanalytics_cron': return 'Cancella le versioni cached di ga.js/urchin.js.';
    case 'xmlsitemap_cron': return 'XML sitemap ping.';
    case 'xmlsitemap_node_cron': return 'Aggiorna la XML sitemap con i nuovi nodi';   
    case 'xmlsitemap_term_cron': return 'Aggiorna la XML sitemap con i nuovi termini';   
    default: return '-';
  }
}
?>